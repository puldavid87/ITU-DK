#include <Arduino.h>
#include <avr/pgmspace.h>
/*
 * [[-0.51918001 -0.59645845  0.61196716 -0.01362484]
 [-0.85389968  0.38640748 -0.34820136 -0.01733228]]
 */
const PROGMEM float matriz [245][3]={
{0.33,0.02,1.0},
{0.68,-0.13,1.0},
{-0.18,0.25,2.0},
{-0.22,0.19,2.0},
{-0.06,0.25,2.0},
{-0.38,0.18,2.0},
{-0.36,-0.2,4.0},
{-0.29,0.08,2.0},
{-0.19,0.17,2.0},
{-0.47,-0.03,2.0},
{0.01,0.3,2.0},
{-0.36,-0.2,4.0},
{0.41,0.31,1.0},
{-0.2,-0.13,4.0},
{-0.23,-0.14,4.0},
{-0.22,0.16,2.0},
{-0.13,0.04,4.0},
{0.53,0.05,1.0},
{-0.27,0.28,2.0},
{0.7,-0.15,1.0},
{0.69,-0.13,1.0},
{-0.34,-0.17,4.0},
{-0.33,-0.16,4.0},
{-0.33,-0.15,4.0},
{0.6,-0.07,3.0},
{0.25,-0.08,1.0},
{-0.37,0.15,2.0},
{-0.37,-0.2,4.0},
{0.7,-0.14,1.0},
{-0.41,0.04,2.0},
{-0.37,0.52,2.0},
{-0.33,-0.16,4.0},
{-0.32,-0.13,4.0},
{-0.38,0.13,2.0},
{-0.26,0.16,2.0},
{-0.23,-0.12,4.0},
{-0.34,-0.16,4.0},
{-0.25,0.3,2.0},
{-0.09,0.06,4.0},
{-0.13,0.05,4.0},
{0.29,-0.19,1.0},
{-0.37,0.14,2.0},
{-0.34,0.01,2.0},
{-0.29,0.24,2.0},
{-0.38,0.14,2.0},
{-0.37,-0.23,4.0},
{0.74,-0.11,1.0},
{-0.33,0.06,2.0},
{0.8,-0.13,1.0},
{0.49,0.08,3.0},
{-0.4,0.01,2.0},
{-0.37,-0.2,4.0},
{-0.25,0.16,2.0},
{-0.05,0.31,2.0},
{0.61,-0.0,1.0},
{-0.37,-0.17,4.0},
{0.46,0.06,1.0},
{-0.3,-0.15,4.0},
{0.42,-0.38,1.0},
{-0.37,0.17,2.0},
{0.08,-0.02,1.0},
{0.12,0.1,1.0},
{-0.29,0.26,2.0},
{-0.13,0.04,4.0},
{-0.37,-0.22,4.0},
{-0.2,-0.13,4.0},
{-0.18,0.23,2.0},
{-0.27,-0.21,4.0},
{0.39,-0.1,1.0},
{-0.37,-0.21,4.0},
{-0.02,0.24,2.0},
{-0.37,-0.21,4.0},
{-0.37,-0.22,4.0},
{-0.42,-0.01,2.0},
{0.63,-0.03,1.0},
{0.37,-0.19,1.0},
{-0.34,0.06,2.0},
{0.64,0.06,3.0},
{-0.32,-0.13,4.0},
{-0.04,0.27,2.0},
{0.62,-0.04,1.0},
{-0.24,0.23,2.0},
{-0.32,0.0,2.0},
{0.18,-0.04,1.0},
{0.72,-0.16,1.0},
{-0.28,0.27,2.0},
{-0.32,-0.15,4.0},
{-0.38,0.14,2.0},
{-0.36,-0.23,4.0},
{0.72,-0.08,1.0},
{0.62,0.19,3.0},
{0.64,-0.08,1.0},
{-0.35,0.08,2.0},
{-0.29,-0.15,4.0},
{0.5,-0.03,1.0},
{-0.03,0.03,4.0},
{0.05,0.35,2.0},
{0.21,-0.01,1.0},
{0.49,-0.0,1.0},
{0.26,-0.21,1.0},
{-0.38,-0.21,4.0},
{-0.36,-0.16,4.0},
{0.25,0.07,1.0},
{-0.11,0.05,4.0},
{-0.34,-0.18,4.0},
{-0.37,-0.19,4.0},
{0.35,-0.45,1.0},
{0.58,0.05,1.0},
{0.7,-0.09,1.0},
{-0.36,-0.19,4.0},
{-0.28,0.16,2.0},
{-0.19,-0.12,4.0},
{0.59,0.32,1.0},
{0.51,-0.06,1.0},
{-0.31,-0.13,4.0},
{0.12,-0.0,1.0},
{0.73,-0.1,1.0},
{0.75,-0.11,1.0},
{-0.39,0.13,2.0},
{0.55,0.06,1.0},
{-0.38,-0.21,4.0},
{-0.21,-0.12,4.0},
{-0.36,-0.2,4.0},
{-0.02,0.36,2.0},
{-0.33,-0.16,4.0},
{0.22,0.17,1.0},
{-0.33,-0.16,4.0},
{-0.37,-0.21,4.0},
{-0.19,0.14,2.0},
{-0.37,0.0,2.0},
{-0.38,-0.23,4.0},
{0.69,0.16,3.0},
{-0.37,-0.23,4.0},
{0.75,-0.11,1.0},
{-0.41,0.02,2.0},
{-0.05,0.26,2.0},
{-0.21,-0.1,4.0},
{-0.26,-0.1,4.0},
{-0.28,0.29,2.0},
{-0.43,-0.02,2.0},
{-0.14,0.04,4.0},
{-0.18,0.18,2.0},
{-0.26,-0.09,4.0},
{-0.23,0.2,2.0},
{-0.36,-0.21,4.0},
{-0.38,0.13,2.0},
{0.69,-0.13,1.0},
{-0.3,0.07,2.0},
{-0.43,-0.03,2.0},
{0.78,-0.12,1.0},
{-0.23,0.21,2.0},
{-0.38,-0.21,4.0},
{-0.24,0.22,2.0},
{-0.23,-0.15,4.0},
{-0.38,-0.2,4.0},
{-0.38,0.13,2.0},
{0.72,-0.16,1.0},
{0.76,-0.1,1.0},
{0.76,-0.1,1.0},
{0.53,0.32,1.0},
{-0.24,-0.11,4.0},
{-0.19,0.28,2.0},
{0.39,-0.02,3.0},
{0.15,-0.01,1.0},
{-0.35,0.05,2.0},
{-0.38,-0.23,4.0},
{-0.32,0.22,2.0},
{-0.28,0.14,2.0},
{0.26,-0.22,1.0},
{-0.26,0.11,2.0},
{-0.23,0.15,2.0},
{0.23,0.05,3.0},
{-0.19,0.19,2.0},
{-0.36,-0.21,4.0},
{-0.26,-0.19,4.0},
{0.64,0.26,3.0},
{0.38,-0.01,1.0},
{0.74,-0.17,1.0},
{0.27,0.1,3.0},
{0.64,0.27,1.0},
{-0.38,0.13,2.0},
{-0.02,0.35,2.0},
{-0.2,0.27,2.0},
{-0.31,-0.13,4.0},
{-0.38,-0.21,4.0},
{-0.23,0.23,2.0},
{-0.31,-0.12,4.0},
{-0.2,0.2,2.0},
{0.33,-0.06,1.0},
{-0.22,-0.09,4.0},
{0.55,-0.06,1.0},
{-0.01,0.34,2.0},
{-0.22,0.17,2.0},
{0.69,-0.13,1.0},
{0.12,0.0,1.0},
{-0.36,-0.17,4.0},
{0.74,-0.11,1.0},
{-0.38,0.02,2.0},
{-0.36,-0.16,4.0},
{0.7,-0.09,1.0},
{0.61,-0.0,1.0},
{-0.31,-0.12,4.0},
{-0.19,0.17,2.0},
{0.32,0.03,1.0},
{-0.33,0.02,2.0},
{-0.38,0.14,2.0},
{-0.28,0.27,2.0},
{-0.35,-0.19,4.0},
{0.44,0.22,3.0},
{0.5,0.01,1.0},
{0.48,-0.02,1.0},
{-0.19,0.16,2.0},
{-0.34,-0.01,2.0},
{-0.38,-0.21,4.0},
{-0.18,-0.13,4.0},
{-0.29,0.25,2.0},
{-0.37,-0.21,4.0},
{-0.31,0.09,2.0},
{-0.2,0.18,2.0},
{0.48,0.25,3.0},
{-0.35,-0.19,4.0},
{-0.41,0.04,2.0},
{-0.31,-0.12,4.0},
{0.43,0.3,1.0},
{0.17,-0.01,1.0},
{-0.38,0.13,2.0},
{-0.21,-0.14,4.0},
{-0.26,0.16,2.0},
{-0.17,-0.12,4.0},
{0.72,-0.11,1.0},
{0.68,0.15,3.0},
{-0.2,0.23,2.0},
{0.74,-0.17,1.0},
{0.62,0.27,1.0},
{-0.24,-0.14,4.0},
{-0.33,-0.17,4.0},
{-0.37,-0.2,4.0},
{-0.3,-0.16,4.0},
{0.56,-0.04,1.0},
{0.74,0.2,3.0},
{-0.36,-0.2,4.0},
{0.66,0.2,3.0},
{0.0,0.34,2.0},
{0.65,-0.17,1.0},
{-0.26,0.17,2.0}
};

void setup_1(){
 Serial.begin(9600); 
 }

uint8_t knn (uint8_t k,uint8_t etiquetas, uint8_t tam_col, uint8_t tam_fil, float *datos_prueba){
float pca_vector[tam_col-1];
uint8_t col;
uint8_t fil;
uint8_t i=0;
uint8_t j; 
uint8_t etiqueta;
  float aux;
  float aux_eti=0;
  float sumatoria=0; // sumatoria de la elevación al cuadrado de cada col
  float distancia=0; // raiz de sumatoria
  
  /*matriz de k-vecinos
  |1|2|3| -> numero de vecinos
  |2|1|1| -> asginacion del vecino por etiqueta
  |0.1|0.2|0.3| -> distancia
  */
 float matriz_k [3][k];
 
  /* etiquetas
  |1|2|3| -> etiquetas que existe dentro de la base de datos
  |2|1|0| -> conteo de etiquetas dentro de los k-vecinos
   */
 int matriz_etiq[2][etiquetas];
  // asignar numero de vecinos y enceramos asignación de etiqueta

   for(;i<k;i++){
      matriz_k[0][i]=i+1.0;
      matriz_k[1][i]=0;
      matriz_k[2][i]=3000.0+i;
    /*
     |1|2|3|
     |0|0|0|
     |3000|3001|3002|
     */
    }
   // asignar etiquetas y enceramos su contador
   for(i=0;i<etiquetas;i++){
    matriz_etiq[0][i]=i+1;
    matriz_etiq[1][i]=0;
    /*
     |1|2|3| 
     |0|0|0|
     */
    }

    /*PASOS PARA K-NN
     * Leer cada fila de la matriz de entrenamiento
     * distancia entre la fila de la matriz con la nueva instancia (vector de prueba)
     * ordenar la matriz matriz_k (determinar los k vecinos de menor distancia)
     * contar las etiquetas en la matriz_k y asignar en matriz etiquetas
     * eligo al mayor número de matriz etiquetas
     * retorno la etiqueta resultante
     * 
     */
    
    pca_vector[0]= (-0.30*(datos_prueba[0]/828.0))+(-0.50*(datos_prueba[1]/660.0))+(0.81*(datos_prueba[2]/483.0))+(-0.11*(datos_prueba[3]/79.0));
    pca_vector[1]= (0.16*(datos_prueba[0]/828.0))+ (-0.70*(datos_prueba[1]/660.0)) +(-0.28*(datos_prueba[2]/483.0))+ (0.62*(datos_prueba[3]/79.0));

     for(fil=0;fil<tam_fil;fil++){
         for(col=0;col<tam_col-1;col++){ // menos 1 por ultima columna es etiqueta
             sumatoria=sumatoria+pow(pgm_read_float(&matriz[fil][tam_col-1])-pca_vector[col],2);
          }
             distancia=sqrt(sumatoria);
             // comparación de nuevo dato con solo la distacia mayor almacenada en matriz_k
              if(distancia<matriz_k[2][k-1]){
                 matriz_k[2][k-1]=distancia;
                 matriz_k[1][k-1]=pgm_read_float(&matriz[fil][tam_col-1]);//matriz[fil][tam_col-1];       //pgm_read_float(&matriz[fil][tam_col-1]);
                 //ordenar por metodo burbuja
                 for (i=0;i<k;i++){
                     for(j=i+1;j<k;j++){
                          if(matriz_k[2][i]>matriz_k[2][j]){
                            //distancia
                             aux=matriz_k[2][i];
                             matriz_k[2][i]=matriz_k[2][j];
                             matriz_k[2][j]=aux;
                             // etiqueta
                              aux_eti=matriz_k[1][i];
                             matriz_k[1][i]=matriz_k[1][j];
                             matriz_k[1][j]=aux_eti;
                            } //end if
                      } //end for
                  }
                 //fin ordenamiento 
              } 
              //fin condicion de numero menor
              sumatoria=0;
        }
        // fin de lectura de matriz
        // contar por columna, cuantos vecinos hay por etiqueta
        for(i=0;i<etiquetas;i++){
          for(j=0;j<k;j++){
              if(matriz_etiq[0][i]==matriz_k[1][j]){
                 matriz_etiq[1][i]++;
                }
            }
          }

         // buscar la etiqueta con mayor numero de vecinos
           aux_eti=-1.0;
        for(i=0;i<etiquetas-1;i++){
            if(matriz_etiq[1][i]>aux_eti){
              etiqueta=matriz_etiq[0][i];
              aux_eti=matriz_etiq[1][i];
            }
           // Serial.println(etiqueta);  
          }
        
        return etiqueta;    
     }
